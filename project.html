<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Backtracking</h1>
    <p> Backtracking is a form of recursion. <br/><br/>
    The usual scenario is that you are faced with a number of options and you must choose one of these . After you make your <br/>
choice you will get  a new set of options; just what you set of options you get depends on what choice you made. This procedure is <br/>
repeated over and over until you reach a final state. If you made a good sequence of choices ypur final stste is a goal state . If <br/>
you didnt, it isn't.
<br/>
<br/>
The usual scenario is that you are faced with a number of options and you must choose one of these . After you make your <br/>
choice you will get  a new set of options; just what you set of options you get depends on what choice you made. This procedure is <br/>
repeated over and over until you reach a final state. If you made a good sequence of choices ypur final stste is a goal state .
<br/>
<br/>
The usual scenario is that you are faced with a number of options and you must choose one of these . After you make your <br/>
choice you will get  a new set of options; just what you set of options you get depends on what choice you made. This procedure is <br/>
repeated over and over until you reach a final state. If you made a good sequence of choices ypur final stste is a goal state .
<br/>
<br/>
<br/>
This needs an example.
<br/>
</p>

<img src="backtracking.jpg"  heigh="200" width="400">
<ol type="number">
    <li>Starting at Root, your options are A and B. You choose A.</li>
    <li>At A, your options are C and D. You choose C.</li>
    <li>C is bad. Go back to A.</li>
    <li>4.	At A, you have already tried C, and it failed. Try D.</li>
    <li>D is bad. Go back to A.</li>
    <li>At A, you have no options left to try. Go back to Root.</li>
    <li>At Root, You have aiready tried A. Try B.</li>  
    <li>At B, your options are E and F. Try E.</li>
    <li>E is good. Congratulations!</li>

</ol>
<p> In ihfs example we drew a picture of a tree. The tree is an abstract model of The possible sequences of choices we covfd<br/>
     make. There Is also a data structure called a tree, but usually we don't havea data structure to tell us what choices we <br/>
     have. flf we do have an actual tree data structure, backtracking on it Is called depth-first tree searching.</p>

    <h3> The Backtracking Alogorithm</h3>
    <div style=" width: 30%; color:blue; border: 1px solid black; margin-left:20; ">
        <p>
            boolean solve(Node n) <br/>
            if n is a leaf code {<br/>
            if the leaf is a goal node, return true <br/>
            else return False<br/>
            }else{ <br/>
                for each child c of n {<br/>
                    if solve(c) succeeds, return true <br/>
                }<br/>
                return false <br/>
            }<br/>
        </p>
    </div>

    <p>Notlce that the algorithm is expressed as a boolean function. This Is essential to understanding the algorithm. If<br/>
         solve(n) Is true, that means node n is part of a solution--that \s, node n is one of the nodes on a path from the root to <br/>
         some goal node. We say that n is solvable. If solve(n) is false, then there is no path that includes n to any goal node.

    </p>
    <h3>How Does it Works?</h3>
    <ul>
        <li>If any chlld of n is solvable, then n is solvable.</li>
        <li>If no child of n is solvable, then n is not solvable.</li>
    </ul>
    <p>Hence, to decide whether any non-leaf node n is solvable apart of a path to a goal node, all you have to do is test whether any<br/>
         child of n is solvable. This is done rccursively, on each child of n. In the above code, Ihis is done by the lines

    </p>
    <div style="width: 30%; color:blue; border: 1px solid black;">
        <p>
            fat each chlld c of n {<br/>

            if solve(c) succeeds, return true<br/>
            }<br/>

        retern faise<br/>


        </p>
    </div>
    <p>Eventually the recUrsion wlll "botfom" out at a leaf node I f the ieai node is a goal node, it ls solvable; if the ieaf node is not a goal <br/>
        node, it is not solvable. This is our base case. In trte above co0e, this is aone by the Lines.</p>

        <div style="width: 30%; color:blue; border: 1px solid black;">
            <p>
                if n is a leaf node {<br/>
                if the leaf is a goal node, return true <br/>
                else return false<br/>
                }<br/>


            </p>
        </div>
        <p>
            The backtracking algsriEhm is simple Dut important. You should understand it thoroupLily. Ano!fter way of stating it !s as follows:
        </p>

        <h4>To Search a Tree:</h4>
        <ol type="number">
            <li>If the tree consists of a single leaf, tes: wnether it is a goal node.</li>
            <li>Otherwise, search the subtrees unEil you find one containing a goal node, or Ltntil you have <br/>
                searched them all unsuccessfully.

            </li>
        </ol>
        <h4>Non-recursive backtracking, using a stack</h4>
        <p>Backtracking is a rather typlcal recursive algorithm, and any recursive algorithm can be rewritten as a stack algorithm. In face,<br/>
             that is how your recursive algorithms are translated into machine or assembly language.</p>

             <div style="width: 30%; color:blue; border: 1px solid black;">
                <p>
                    boolean solve(Node n) {<br/>
                    put node n on the stack;<br/>
                    while the stack is not empty {<br/>
                    If ihe node at the top of the stack 1s a leaf {<br/>
                    if it is a goa1 node, return true<br/>
                    etse pop it off the stack<br/>
                    }<br/>
                    else {<br/>
                      If the node at the top of the stack has untried children push the next untried child onto thé stack<br/>
                    else pop tne node otf the stack<br/>

                    }<br/>
                    return false<br/>
                    }<br/>
                    }<br/>
                </p>
             </div>

             <p>
                Starting from the root, the only nodes tnat can be pushed onto the stack are the children of the node currently on ths' tap of the <br/>
                stacx, and these are only pushed on one cniid at a time; hence, the nodes on the stack at all times describe a valid path in the<br/>
                Starting from the root, the only nodes that can be pushed onto the stack are the cniioren of the node currently on the top <br/>
                o! 1he slack, and ihese are only pushed an one child at a ‹ime; hence, ihe nodes on the stack at all times describe a valid path in the<br/>
                 tree. Nodes are removed from the stack only when it Is known tnat tney have no goal nodes aiTtong their descendents. Therefore, <br/>
                 ñtne ootnodegeTs removed(makogthestaukempty),lheremuslDavebeennogoal nodesatal. and no solution to the problem.
                 <br/>
                 <br/>
                 when the stack algorithm terminates successfully, the nodes an the stdck form (in reverse order) a path from the root to a goal node.
                 <br/>
                 Similarly, when the recursive algorithm finds a goal code, the path information is embodied (in reverse order) in the sequence of<br/>
                  recursive calls. Thus as the recursion unwinds, the path can be recovered one node at a time, by (lor instance) printing the node<br/>
                   at lhe current leyel, or storing It in an array.<br/>
                   <br/>
                   Here is the recursive backtracking algorithm, modified slightly to  print (in reverse order) the nodes along the successful path:
             </p>
             <div style="width: 30%; color:blue; border: 1px solid black;">
                <p>
                    boolean solve(Node n) {<br/>
                    If n is a leaf node {<br/>
                    If the leaf is a goal node {<br/>
                    print n <br/>
                    return true<br/>
                    }<br/>

                    else return false</p>

                    for each chlld c of n {<br/>
                    If solve(c) succeeds {<br/>
                     Boolean solve(Node n) {<br/>
                     If n 1s a leaf node {<br/>
                    If the leaf iS a goal node {<br/>
                     print n<br/>
                     return true<br/>
                    }<br/>
                    else relurn false<br/>
                      } else {<br/>
                    for each child c of n {<br/>
                    If solve(c) succeeds <br/>
                    return true<br/>
                    }<br/>
                      }<br/>
        
                    return false<br/>
                     }<br/>
                    }<br/>
        
        
                </p>
             </div>
             <h3>Keeping Backtracking Simple </h3>
             <p>
                All of these versions of the backtracking algorithm are pretty simple, but when applied to a real problem, they can get pretty <br/>
                cluttered up wi*h details. Even determining whether the node is a leaf can be complex.<br/><br/>

                for example, if lhe path represents a sefies of moves in a chess endgame problem, the leaves are the checkmate and stalemate<br/>
                 solutions.<br/><br/>

                To keep the program clean, therefore, tests like this should be buried in methods. In a chess game, for example, you could tesl <br/>
                whether a node is a leaf by writing a gameover methog (of you cou d even call it isLeaf}. This method wouTd encapsulate all the <br/>
                ug1y de ai s of figuring out an iher any poss\b|e moves remain.<br/><br/>

                 Notice tnat the backtracking aliorithms require us to keep track, for each node on the curfent path, which ol i\s children have been <br/>
                 tried already \so we don’t have to try them agaln) In the above code we made thls \osk simple, by just saying for each child c ef n. <br/>
                 In reality, it may be d f/lcuit to figure out what the possldie children are, and there may be no obvious way to step through them. <br/>
                 In chess, for example, a node can represent one arrangement of pieces on a chessboard, and each Chi|d of that node can represent the<br/>
                arrangement aft=r some piece has made a legal move. How do you find these children, and how do you keep track of which ones <br/>
                you've already examined?<br/><br/>

                The most straightforward way io keep track of which children of the node have been trieo s as follows: Upon initial entry to the node <br/>
                is, when you first get there mom above), make a list of all its children. As you try each child, take ii all the list. When ihe list<br/>
                1s empty, these are no remaining untried children, and you can ‹eturn "failu re." This is a simple approach, but if may require <br/>
                quite a lot of additiona1 work.<br/><br/>

                There is an easier way to keep track of wh1ch children have been tried, if you can deflne an ordering on the children. If there is an<br/>
                ordering, and you know which chlld you just trieo, you can determine which child to try next,





             </p>

             <h4> Example Tree Search</h4>
             <p>
                For starters, let's do the simpler- possible example of backtracking, which Is searching in actual tree. We will also use the saplest <br/>
                sea at \ ee, a bina‹y tree.<br/><br/>

                A binary tree is a oata siiuc sure composed of nodes. One node is designs\ed as the root node. Each node can reference (point to) <br/>
                zero, one, or trio ether nodes, which are called its children. The chlldren arc referred to as the left cnild and/or the right child.<br/>
                 A nodes are reachable lby one or more s•eps) from the root node, and there are no cycles. For our purposes, a though this is not part <br/>
                 of the definition of a b-nary tree, we will say that a node mlght or might not be a goal node, and will con\am its name. <br/><br/>
                 The first example in ‹n s paper (which we repeat here) shows a blnary tree.<br/><br/>

                Here's a definition of fhe binaryTree class:<br/>


             </p>
             <div style="width: 30%; color:blue; border: 1px solid black;">
                <p>
                    boolean solve(Node n) {<br/>
                        put node n on the stack;<br/>
                        while the stack is not empty {<br/>
                        If ihe node at the top of the stack 1s a leaf {<br/>
                        if it is a goa1 node, return true<br/>
                        etse pop it off the stack<br/>
                        }<br/>
                        else {<br/>
                          If the node at the top of the stack has untried children push the next untried child onto thé stack<br/>
                        else pop tne node otf the stack<br/>
    
                        }<br/>
                        return false<br/>
                        }<br/>
                        }<br/>

                </p>
             </div>
             <h3> What are Children?</h3>
             <p>One of fhe lhings fhat s mpfifies the above binary tree search i3 that, at each choice point, you can ignore<br/>
                 all the previous choices. Previous choices don”\ give you any information about what you should do ncx I; as<br/>
                  far as you know, both the left and the rlght child are possible solutions. In many praDlems, however, you may <br/>
                  be a bfe to e‹Iminate children immediately, without recursion.<br/><br/>
                </p>
                <table border="1">
                    
                    <thead>
                        <tr bgcolor="lightgrey">
                            <th></th>
                            <th>2 by 3 map</th>
                            <th>3 by 3 map</th>
                            <th>3 by 4 map</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td bgcolor="lightgrey">method 1 </td>
                            <td>60ms</td>
                            <td>940ms</td>
                            <td>60530 ms.(1 minute)</td>
                        </tr>
                        <tr>
                            <td bgcolor="lightgrey">method 2</td>
                            <td> 0 ms</td>
                            <td> 0 ms. </td>
                            <td>0 ms.</td>
                        </tr>
                    </tbody>

                </table>












    
</body>
</html>